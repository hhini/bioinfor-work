{
  "hash": "423f62ffd758a0aaf131f86da940bb7a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 多元数据分析作业\nauthors:\n  - name: 周杰 113120230073\n    affiliation: The GanNan medical University \n    roles: writing\n    corresponding: true\nbibliography: references.bib\n---\n\n113120230073 周杰\n\n## 设抽了五个样品，每个样品只测了一个指标，它们分别是1 ,2 ,4.5 ,6 ,8。若样本间采用欧式距离，试用最短距离法、最长距离法、类平均法分别对其进行分类，并给出聚类图。\n\n我们有五个样品：\n\nx1=1,x2=2,x3=4.5,x4=6,x5=8x_1 = 1,\\quad x_2 = 2,\\quad x_3 = 4.5,\\quad x_4 = 6,\\quad x_5 = 8x1​=1,x2​=2,x3​=4.5,x4​=6,x5​=8\n\n并采用**欧式距离**（Euclidean distance），即：\n\nd(xi,xj)=∣xi−xj∣\n\n## 一、计算样本间距离矩阵\n\n| 样本    | 1   | 2   | 4.5 | 6   | 8   |\n|---------|-----|-----|-----|-----|-----|\n| **1**   | 0   | 1   | 3.5 | 5   | 7   |\n| **2**   | 1   | 0   | 2.5 | 4   | 6   |\n| **4.5** | 3.5 | 2.5 | 0   | 1.5 | 3.5 |\n| **6**   | 5   | 4   | 1.5 | 0   | 2   |\n| **8**   | 7   | 6   | 3.5 | 2   | 0   |\n\n### 1️⃣ 最短距离法（Single Linkage）\n\n也称为**最近邻法**，类间距离定义为：\n\nD(A,B)=min⁡∈d(i,j)min​d(i,j)\n\n#### 第一步：\n\n最近的两个点是 `1` 和 `2`（距离 = 1），合并为一类：\n\nC_1 = {1,2},\\quad 4.5, 6, 8\n\n#### 第二步：\n\n计算新类与其他类的距离：\n\nd(C1,4.5)=min⁡(3.5,2.5)=2.5\n\nd(C1,6)=min⁡(5,4)=4\n\nd(C1,8)=min⁡(7,6)=6\n\n最近的是 C1​ 与 4.5（2.5），合并：\n\nC_2 = {1,2,4.5},\\quad 6, 8\n\n#### 第三步：\n\n计算：\n\nd(C2,6)=min⁡(5,4,1.5)=1.5​,\n\nd(C2,8)=min⁡(7,6,3.5)=3.5​\n\n于是合并 C2C_2C2​ 和 6：\n\nC_3 = {1,2,4.5,6},\\quad 8\n\n#### 第四步：\n\nd(C3,8)=min⁡(7,6,3.5,2)=2\n\n全部合并完毕。\n\n**合并距离顺序：**\\\n1 → 2（1）\\\n(1,2) → 4.5（2.5）\\\n(1,2,4.5) → 6（1.5）\\\n(1,2,4.5,6) → 8（2）\n\n### 2️⃣ 最长距离法（Complete Linkage）\n\n也称为**最远邻法**：\n\nD(A,B)=max⁡∈d(i,j) \\#### 第一步：\n\n`1` 和 `2` 最近（1），合并：\n\nC_1 = {1,2}C1​={1,2}\n\n#### 第二步：\n\n计算：\n\nd(C1,4.5)=max⁡(3.5,2.5)=3.5\n\nd(C1,6)=max⁡(5,4)=5\n\nd(C1,8)=max⁡(7,6)=7\n\nd(4.5,6)=1.5,d(6,8)=2,d(4.5,8)=3.5d(4.5,6)=1.5, \\quad d(6,8)=2, \\quad d(4.5,8)=3.5d(4.5,6)=1.5,d(6,8)=2,d(4.5,8)=3.5\n\n→ 最近的是 `4.5` 和 `6`（1.5），合并：\n\nC2​={4.5,6}\n\n#### 第三步：\n\n计算：\n\nd(C1,C2)=max⁡(∣1−4.5∣,∣1−6∣,∣2−4.5∣,∣2−6∣)=5 d(C1,8)=7 d(C2,8)=max⁡(3.5,2)=3.5\n\n→ 合并 C2C_2C2​ 与 888（3.5）：\n\nC3={4.5,6,8}\n\n#### 第四步：\n\nd(C1,C3)=max⁡(∣1−4.5∣,∣1−6∣,∣1−8∣,∣2−4.5∣,∣2−6∣,∣2−8∣)=7\n\n最终合并。\n\n**合并距离顺序：**\\\n1 → 2（1）\\\n4.5 → 6（1.5）\\\n(4.5,6) → 8（3.5）\\\n(1,2) → (4.5,6,8)（7）\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nsamples = [1, 2, 4.5, 6, 8]\n\nimport numpy as np\nfrom scipy.cluster.hierarchy import linkage, dendrogram\nimport matplotlib.pyplot as plt\n\n# 数据\nX = np.array([[1], [2], [4.5], [6], [8]])\n\n# 三种方法：最短距离法(single)、最长距离法(complete)、类平均法(average)\nmethods = ['single', 'complete', 'average']\ntitles = ['最短距离法（Single Linkage）', '最长距离法（Complete Linkage）', '类平均法（Average Linkage）']\n\nplt.figure(figsize=(12, 8))\n\nfor i, method in enumerate(methods, 1):\n    # 进行层次聚类\n    Z = linkage(X, method=method, metric='euclidean')\n    \n    # 绘制树状图\n    plt.subplot(1, 3, i)\n    dendrogram(Z, labels=['1','2','4.5','6','8'], color_threshold=0)\n    plt.title(titles[i-1], fontsize=12)\n    plt.xlabel(\"样品编号\")\n    plt.ylabel(\"距离\")\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](qq_files/figure-docx/cell-2-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "qq_files"
    ],
    "filters": []
  }
}